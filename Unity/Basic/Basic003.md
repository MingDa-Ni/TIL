# Unity - Basic
## 2022-10-03 Mon

## 유니티 엔진이 동작하는 원리

### 상속과 재사용
* 게임 엔진은 완성된 기반 코드를 제공한다.
  - 게임 엔진 코드를 `재사용`하며 능률이 오른다.
  - 코드를 재사용하는 `상속`을 알아야한다.
  - `상속` : 이미 만들어진 클래스에 새로운 코드와 기능을 덧붙여 클래스를 만드는 방법
      - `기초를 제공`하는 클래스 : 부모 클래스
      - 상속해서 `확장`한 클래스 : 자식 클래스
* 클래스 
  - 묘사할 대상과 관련된 코드`(변수와 메서드 등)`를 묶는 틀
  ```
  class Monster {
    // 몬스터 변수 및 클래스
  }
  ```

* 상속으로 몬스터 제작
  - 개발자는 슬라임과 슬라임 대장을 만들려고 한다.
  - `몬스터 클래스를 먼저` 만들고, 남은 세 클래스가 다른 상속관계를 갖게 한다.
    - class Monster
    - class Slime : Monster
    - class SlimeChieftan : Slime

* `class Monster`
  - 인공지능
  - 애니메이션
  - 공격과 방어
  - 물리
    - 제대로 된 외형이 없다.
    - 파생 몬스터를 여럿 만들어야하기 때문이다.
* `class Slime : Monster`
  - 피부
  - 애니메이션
  - 스킬
  - 고유 기능
    - `(:)`은 오른쪽 클래스를 상속해 왼쪽 클래스를 만든다는 의미이다.
    - Monster 클래스를 기반으로 Slime을 만든다.

* `class SlimeChieftan : Slime`
  - 대장 왕관
  - 강력한 스킬과 새 무기
  - 고유 기능

* 상속의 한계
  - 상속에만 의존하면 `오히려 재사용하기 어려울 수 있다.` 
  - Human
    - 렌더 기능
    - 물리 기능 
    - 애니메이션 기능
    - 체력 기능
  - NPC
    - 대화 기능
    - 거래 기능
  - `상속`으로 인해 NPC를 만들기 위해 `물리와 체력` 기능을 삭제하는 추가 작업이 생겼다.
    1. 오히려 `코드를 재사용하기 힘든 경우`가 생길 수 있다.
    2. 기획자가 새로운 오브젝트를 만들 때 `프로그래머에게 의존`해야 한다.


### 컴포넌트와 조립
* 게임 오브젝트는 게임 월드에 존재하는 `하나의 물체`이다.
  - 게임 오브젝트를 컴포넌트 패턴을 사용해 만든다.
* 컴포넌트 패턴(Composition)
  - `미리 만들어진 부품`을 조립하여 오브젝트를 만드는 방식
  - 컴포넌트라 부르며 저마다 `대표 기능`을 지닌다.
  - 컴포넌트에서 게임 오브젝트는 `겉 껍데기`일 뿐이다.
* 컴포넌트로 `오브젝트` 만들기
  1. 빈 게임 오브젝트 생성
  2. 알맞은 컴포넌트를 추가
* 컴포넌트의 장점
  - `유연한 재사용`이 가능하다.
  - 프로그래머 `의존도`가 낮아진다.
  - 독립성으로 인한 `기능 추가와 삭제`가 쉽다.
    - 코드의 한 부분만 수정하더라도 `다른 기능이 망가지지 않는다.`
* 컴포넌트의 독립성
  - `게임 오브젝트는 단순한 빈 공간`
    - 몇 가지 식별기능
    - 어떠한 컴포넌트가 있는지 알 수 있는 기능
  - 컴포넌트는 `독립적`인 부품

### 유니티 에디터와 컴포넌트

* 컴포넌트를 추가할 때
  - `Add Component`를 클릭
* 특정 컴포넌트를 제거할 때
  - `(⁝)` → Remove Componet

### 메시지와 브로드캐스팅

* 브로드캐스팅(i)
  - 컴포넌트는 `전체 방송`을 이용해 특정 기능을 `간접적`으로 실행할 수 있다.
* MonoBehaviour
  - 브로드캐스팅의 원리를 알기 위해
    - 모든 컴포넌트는 `MonoBehaviour`을 상속한다.
    - Monobehaviour을 상속한 클래스는 `게임 오브젝트에 컴포넌트로서` 추가될 수 있다.
    - Monobehaviour을 상속한 클래스는 `유니티의 제어`를 받는다.
    - 유니티의 제어를 받기 때문에 `유니티의 메시지`를 들을 수 있다.
* 메세지 기반 방식
  - 컴포넌트는 독립적이라 `일부러 찾기` 전까지는 서로의 존재를 모른다.
  - 유니티는 컴포넌트 기능을 실행시키고 싶을 때 메시지를 날린다.
    - 유니티(사장)는 발동시키고 싶은 기능의 이름을 `모두(오브젝트)에게 뿌린다`.
    - 오브젝트(사원)는 기능을 가지고 있다면 `실행`, 그렇지 않다면 `무시`한다.
  - `이렇게 동시에 여러 오브젝트에 메시지를 뿌리는 것을 브로드캐스팅이라 한다.`
* 브로드캐스팅(ii)
  - 각 컴포넌트는 `여러 기능(메서드)`를 가지고 있다.
  - 그 중 Minda() 기능을 실행하려 한다.
  - `단 한 번의 브로드케스팅으로 Minda()를 가진 모든 컴포넌트가 그 기능을 실행한다.`
  - 브로드캐스팅은 `다른 컴포넌트에 의존하지 않고 독립적으로 동작할 수 있는 구조를 가진 이유다.`
* 유니티 이벤트 메서드
  - 메시지와 브로드캐스팅은 `유니티 이벤트 메서드`가 동작하는 원리다.
    - Start()
    - Update()
    - OnTriggerEnter()
  - Start()는 게임 오브젝트가 활성될 때 자동 한 번 실행된다.
    - 해당 게임 오브젝트를 브로드캐스팅하기 때문이다.
    - 유니티엔 이런식으로 `자동 실행`되는 메서드들이 있다.
    - `유니티 이벤트 함수` 또는 `유니티 이벤트 메서드`라고 한다.