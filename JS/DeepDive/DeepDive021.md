# JS - DeepDive
## 2022-12-06 Tue

### 함수 정의


#### 함수 선언문

* 함수 정의
  * 함수를 호출하기 이전에 하단의 내용을 저장하는 것
    1. 인수를 전달받을 매개변수와 실행할 문들
    2. 반환할 값

* 함수 정의 방식
  1. 함수 선언문
    ```javascript
    function plus(x, y){
      return x+y;
    }
    ```
  
  2. 함수 표현식
  ```javascript
  var plus = function (x,y){
    return x+y;
  };
  ```

  3. Function 생성자 함수
  ```javascript
  var plus = new Function('x', 'y', 'return x+y');
  ```
  4. 화살표 함수(ES6)
  ```javascript
  var plus = (x,y) => x+y;
  ```

### 함수 선언문
  ```javascript
  // 함수 선언문
  function plus(x, y){
    return x+y;
  }
  ```
  * 함수 리터럴과 형태가 동일하다.
  * `함수 이름을 생략할 수 없다.`
  * `표현식이 아닌 문이다.`
    * 함수 선언문을 실행하면 `완료값 undefined`가 출력된다.
    * 표현식인 문이라면 `표현식이 평가`되었어야 한다.

* 변수 선언과 함수 정의
  * 변수는 `선언 declaration`
  * 함수는 `정의 definition`
    * 식별자가 암묵적으로 생성
    * 함수 객체가 할당

* 변수 할당과 리터럴
  * 표현식이 아닌 문은 변수에 할당할 수 없다.
    * 함수 선언문도 `표현식이 아닌 문`이므로 변수에 할당할 수 없다.
  * 함수 선언문이 `변수에 할당되는 것`처럼 보이는 이유
    ```javascript
    // 함수 선언문이 변수에 할당되는 것처럼 보이는 이유
    var plus = function plus(x, y){
     return x+y;
    };
    ```
    * 코드 문맥에 따라 다음과 같이 해석되기 때문이다.
      1. 함수 선언문으로 해석 : 표현식이 아닌 문
      2. 함수 리터럴로 해석 : 표현식인 문
  
* 함수 선언문 vs 함수 리터럴
  * 함수 선언문
    * `함수 이름`을 생략할 수 없다.
    * 함수 이름이 있는 함수 리터럴을 `단독`으로 사용
  * 함수 리터럴
    * 함수 리터럴이 `값으로 평가`되어야 하는 문맥
    * 함수 리터럴을 `변수에 할당`하거나 `피연산자`로 사용

* 비슷한 예제(객체와 블록문)
  * { }
    * { }을 단독으로 사용하면 블록문
    * { }이 값으로 평가되어야하는 문맥
      * 피연산자로 사용되면 객체 리터럴

* 함수 생성 내부 동작 차이
  ```javascript
  function hello() { console.log('hello'); }
  hello();
  ```
  * 단독으로 사용되어 `함수 선언문`
  ```javascript
  (function bye() {console.log('bye');});
  bye(); // ReferenceError : bar is not defined
  ```
  * 그룹 연산자 `()` 내에 있으므로 `함수 리터럴 표현식`
    * 그룹 연산자의 피연산자는 `값으로 평가될 수 있는 표현식`
    * 따라서 `함수 선언문`은 피연산자로 사용 불가
  * bar는 호출 불가
    * `함수 리터럴의 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자`
    * 함수 몸체 외부에서는 `함수를 가리키는 식별자가 존재하지 않는다.`


#### 함수 표현식

* 일급 객체
  * 함수는 객체 타입의 값
    * 함수를 값처럼 자유롭게 사용할 수 있음
    1. 값처럼 `변수에 할당`할 수 있음
    2. `프로퍼티 값`이 될 수 있음
    3. `배열의 요소`가 될 수 있음
  * 함수는 일급 객체므로 `함수 리터럴 생성된 함수 객체를 변수에 할당할 수 있다.`
  * 이러한 정의를 함수 표현식(function expression)이라 한다.

* 함수 표현식(function expression)
  * 변수에 할당한 함수 객체
  ```javascript
  var plus = function (x, y){
    return x+y;
  };

  console.log(add(2, 5));
  ```
  * 함수 리터럴의 함수 이름은 생략할 수 있다.
    * 익명 함수라 한다.
  * `함수 표현식은 함수 이름을 생략하는 것이 일반적`이다.
    * 함수 객체를 가리키는 식별자로 호출해야 한다.
    * 함수 이름은 `몸체 내부에서만 유효한 식별자`이기 때문에 함수를 호출할 수 없다.

* 결론
  * 함수 선언문은 `표현식이 아닌 문`이고 함수 표현식은 `표현식인 문`이다.


#### 함수 생성 시점과 함수 호이스팅
```javascript
// 함수 참조
console.log(plus);
console.log(minus);

// 함수 호출
console.log(plus(2, 5)); // 7
console.log(2, 5); // TypeError: sub is not a function
```

```javascript
// 함수 선언문
function plus(x, y){
  return x+y;
}

// 함수 표현식
var minus = function (x, y){
  return x-y;
};
```
* 함수의 생성시점
  * 함수 선언문으로 정의하면 `함수 선언문 이전에 호출이 가능`하다.
  * 함수 표현식으로 정의하면 `함수 표현식 이전에 호출이 불가능`하다.

* 함수 호이스팅(function hoisting) : 함수 선언문
  * 선언문은 자바스크립트 엔진에 의해 런타임(runtime) 이전에 먼저 실행된다.
  * 함수 선언문 역시 함수 이름과 동일한 이름의 `식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당`한다.
    * 런타임 시점
      1. 이미 객체가 생성
      2. 함수 이름과 동일한 식별자에 할당 완료
    * 따라서 런타임 시점에 `참조와 호출`이 가능하다.
  * `함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 특징을 함수 호이스팅`이라 한다.

* 변수 호이스팅 : 함수 표현식
  * `함수 표현식: 변수에 할당되는 값이 함수 리터럴인 문`
  * 변수 선언문과 변수 할당문을 축약한 행위
    * `변수 선언`은 런타임 이전에 실행되어 undefined로 초기화
    * `변수 할당문의 값은` 할당문이 실행되는 시점(런타임)에 평가
  * 함수 표현식의 함수 리터럴 역시 `실행되는 시점(런타임)`에 평가되어 함수 객체가 된다.
  * `함수 표현식으로 함수를 정의하면 변수 호이스팅이 발생`한다.

* 함수 표현식 이전에 함수 참조
  * undefined로 평가된다.
  * 함수를 호출하면 undefined를 호출하는 것이므로 `타입 에러(TypeError)`가 발생한다.
  * `반드시 함수 표현식 이후에 참조 또는 호출해야 한다.`

* 변수 호이스팅과 함수 호이스팅의 차이
  * 변수 호이스팅
    * var 키워드로 선언된 변수는 `undefined로 초기화`된다.
    * `변수 선언문 이전에` 변수를 참조하면 undefined로 평가
  * 함수 호이스팅
    * 암묵적으로 생성된 식별자는 `함수 객체로 초기화`된다.
    * `변수 선언문 이전에` 변수를 참조하면 함수 호이스팅으로 호출 가능

* 함수 표현식 권장
  * 함수 호이스팅은 `함수 호출 전 반드시 함수를 선언해야한다는 당연한 규칙을 무시`
    * JSON 저자인 더글라스는 `함수 표현식을 권장`한다.