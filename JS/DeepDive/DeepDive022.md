# JS - DeepDive
## 2022-12-07 Web

#### Function 생성자 함수

* 생성자 함수(constructor function)
  * 객체를 생성하는 함수

* Function 생성자 함수
  * JS가 기본 제공하는 빌트인 함수다.
    1. 매개변수 목록과 함수 몸체를 문자열로 전달
    2. new 연산자와 함께 호출
    3. 함수 객체를 생성해서 반환
   ```
   var plus = new Function('x', 'y', 'return x+y');
   ```
  * new 연산자 없어도 동작한다.
  * `일반적이지 않으며 바람직하지도 않다.`
    * 함수 선언문이나 표현식과 다르게 동작하기 때문이다.
    * 클로저(closure)를 생성하지 않는다.

#### 화살표 함수

* 화살표 함수(arrow function)
  * `화살표 함수는 항상 익명 함수로 정의한다.`
  * =>를 사용해 좀 더 간략한 방법으로 선언한다.
    ```
    const plus = (x,y) -> x+y;
    ```
    * 기존 함수 선언문과 함수 표현식을 완전히 대체하진 않는다.
    * 표현만 간략한 것이 아니라 `내부 동작 역시 간략화되어있다.`
      1. 생성자 함수로 사용할 수 없다.
      2. 기존 함수와 this 바인딩 방식이 다르다.
      3. prototype 프로퍼티가 없다.
      4. arguments 객체를 생성하지 않는다.

### 함수 호출
* 방법
  * 식별자
  * 호출 연산자
  ```javascript
  식별자();
  ```
* 호출할 때
  1. 현재의 `실행 흐름 중단`
  2. 호출된 함수로 실행 흐름을 옮김

#### 매개변수와 인수

* 필요성
  * 함수를 실행하기 위해 값을 `외부에서 내부로 전달할 필요`가 있을 경우
    * 매개변수(parameter)를 통해 인수(argument)를 전달
  ```javascript
  function add(x, y){ // x, y는 매개변수
    return x+y;
  // 인수 2, 4가 매개변수 x, y에 순서대로 할당되어 함수 몸체가 실행
  }

  var result = add(2, 4); // 2, 4는 인수
  ```
* 인수
  * 값으로 평가될 수 있는 표현식
  * `함수 호출시` 지정
  * 개수와 타입에 제한이 없음
* 매개변수
  * `함수를 정의할 때` 선언
    * 함수 몸체 내부에서 변수와 동일하게 선언
    * 함수 내부에서만 참조 가능
  * 함수 호출시
    1. 암묵적으로 매개변수 생성
    2. undefined 초기화
    3. 인수가 순서대로 할당

* 인수와 매개변수 개수
  * 매개변수와 인수의 개수가 일치하는지 체크하지 않는다.
    * 개수가 다르다고 에러가 발생하지 않는다.
    * `인수가 할당되지 않은` 매개변수는 undefined다.
    ```javascript
    function add(x, y){
      return x + y;
    }
    console.log(add(2)); // NaN
    ```
    * 인수가 더 많은 경우 `초과된 인수는 무시`
  * 모든 인수는 암묵적으로 `arguments 객체의 프로퍼티`로 보관
    * 초과된 인수 역시 버려지지 않음
    ```javascript
    function add(x, y){
      console.log(arguments);

      return x+y;
    }

    add(8, 9, 10);
    ```
    * arguments 객체는 `매개변수 개수를 확정할 수 없는` 가변 인자 함수를 구현할 때 사용

#### 인수 확인

* 적절한 인수가 전달되었는지 확인
  1. 상위 확장을 도입해 `컴파일 시점`에 부적절한 호출 방지
  ```
  if (typeof x ! == 'number' || typeof y !== 'number')
  {
    throw new TypeError('경고문구');
  }
  ```
  2. `arguments 객체`를 통해 인수 개수 확인
  3. `단축 평가`를 통해 기본값 할당
  ```
  function add(a,b,c) {
    a = a || 0;
    b = b || 0;
    c = c || 0;
    return a + b + c;
  }
  ```
  4. ES6 도입된 매개변수 기본값(인수 체크 및 초기화 간소화)
  ```
  function plus(a=0, b=0, c=0){
    return a + b + c;
  }
  ```

#### 매개변수의 최대 개수
* 매개변수의 최대 개수 
  * ECMAScript에서는 명시적으로 제한하지 않는다.
    * 하지만 물리적 한계로 인해 엔진마다 다른 제한은 있을 수 있다.
    * 최대 몇 개까지 사용해야하는가?
* 매개변수와 순서
  * 함수 호출시 인수의 순서를 고려해야 한다.
    * 함수 사용법을 이해하기 어렵게 만든다.
    * 실수를 발생시킬 수 있다.
    * 개수나 순서가 변경되면 호출 방법도 변경된다.
    * `유지보수성이 나쁘다.`
* 매개변수의 이상적인 개수
  * `매개변수는 코드를 이해하는 데 방해되는 요소`이다.
    * 이상적인 매개변수 개수는 0개
    * 적을수록 좋다.
  * 매개변수가 많다는 것은 `함수가 여러가지 일을 한다는 증거`이다.
    * `이상적인 함수는 한가지 일만 하며 가급적 작게 만든다.`
  * 따라서 매개변수는 최대 3개를 넘지 않는 것을 권장한다.
  * 그 이상은 `객체를 인수로 전달`하는 것이 유리하다.
    * 이 경우 `프로퍼티 키`만 정확히 지정하면 `매개변수의 순서를 신경쓰지 않아도` 된다.
    * 명시적으로 인수의 의미를 설명하기에 `코드의 가독성과 실수를 줄일 수 있다.`
    * 하지만 `부수 효과`가 발생하니 주의해야한다.

#### 반환문

* 기능
  1. 함수의 실행을 중단하고 함수 몸체를 빠져나간다.
  ```javascript
  function add(x, y){
    return x + y;
    // 반환문 이후는 실행되지 않고 무시
    console.log('실행되지 않음');
  }

  console.log(add(4,2));
  ```
  2. retrun 뒤에 오는 표현식을 `평가해 반환`, 지정하지 않으면 `undefined 반환`
  ```javascript
  function ex(){
    return;
  }

  console.log(ex()); // undefined
  ```
  3. 반환문은 생략할 수 있다. 이때 암묵적으로 undeifined가 반환
  ```javascript
  function ex(){

  }
  console.log(ex()); // undefined
  ```
  4. 반환문 사이에 줄바꿈이 있으면 `의도치 않은 결과` 발생 → 세미콜론 자동 삽입 기능
  ```javascript
  function add(x, y){
    return 
    x + y;
  }

  console.log(add(4,2)); // undefined
  ```
  5. 함수 몸체 내에서만 사용할 수 있으며, 전역 사용시 `문법 에러(SyntaxError)`
      * Node.js 모듈 시스템에 의해 `독립적인 파일 스코프`
      * 가장 바깥 영역에 반환문을 사용해도 에러는 발생하지 않음
* 특징
  * 반환문은 생략할 수 있다.
    * 이 경우 마지막 문까지 실행한 후 `암묵적으로 undefined`를 반환한다.
  * return과 표현식 사이의 줄바꿈이 있으면 `세미콜론이 추가`되어 의도치 않은 결과가 나온다.
  * 전역에서 반환문을 사용하면 `문법 에러`가 발생한다.

  

