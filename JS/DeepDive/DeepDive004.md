# JS - DeepDive
## 2022-10-31 Mon

## 변수와 메모리

```javascript 
var add = 2 + 3;
```
* add
  * 연산을 통해 생성된 5는 메모리 공간에 저장된다.
  * add는 5를 다시 읽어 재사용할 수 있도록 `메모리 공간을 상징`하는 이름이다.
    * 메모리 공간에 저장된 값을 식별할 수 있는 이름이 `변수 이름`이다.
    * 변수에 저장된 값을 `변수 값`이라고 한다.
* 네이밍
  * 변수에 저장된 값의 의미를 파악할 수 있도록 `값의 의미`를 명확히 하는 이름을 사용
    * 명확한 네이밍은 코드를 이해하기 쉽게 한다.
    * 협업과 품질 향상에 도움을 준다.

### 참조 요청
* 참조 요청
  * 변수 이름을 통해 참조를 요청할 때
    1. 변수 이름과 매핑된 메모리 주소를 통해 `메모리 공간에 접근`한다.
    2. 저장된 값을 반환한다.

### 식별자
* 식별자
  * `어떤 값을 구별해서 식별할 수 있는 고유한 이름`
  * 식별자는 `값이 아니라 메모리 주소를 기억한다.`
    * 식별자 add는 값 5가 저장되어 있는 메모리 주소를 기억해야한다.
    * 식별자는 메모리 주소와 `매핑 관계`를 맺으며, `매핑 정보도 메모리에 저장된다.`
    * 따라서 식별자는 `메모리 주소에 붙인 이름`이다.
  * 변수 이름에만 국한하지 않는다.
    * 변수
    * 함수 (자바스크립트에서 함수는 값이다.)
    * 클래스
* 위는 모두 `declaration(선언)`을 통해 식별자의 존재를 알려야한다.

* 실행 컨텍스트(execution context)
  * 모든 식별자는 실행 컨텍스트에 등록된다.
    1. 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위한 환경을 제공
    2. 코드의 실행 결과를 실제로 관리
  * 실행 컨텍스트를 통해 `식별자와 스코프`를 관리한다.
  * 변수 이름과 변수 값은 그 안의 키/값 형식의 객체로 등록되어 관리된다.

### 변수 선언
* 변수 선언이란?
  * variable declaration(변수 생성)을 의미
    * `값을 저장`하기 위한 메모리 공간을 확보
    * 변수 이름과 확보된 메모리 공간의 주소를 `연결`
  * 확보된 메모리 공간은 `해제되기 전까지 누구도 확보된 메모리 공간을 사용할 수 없도록` 보호된다.
  * 변수를 사용하려면 `반드시 선언이 필요`하다.
    * var
    * let
    * const

* var
  * block-level scope(블록 레벨 스코프)를 지원하지 않는다. 
  * function-level scope(함수 레벨 스코프)를 지원한다.
  * `의도치 않게 전역 변수가 선언되어 부작용을 도래할 수 있다.`

* 키워드
  * 자바스크립트 코드를 해석하고 엔진이 수행할 동작을 규정한 `명령어`다.
    * 키워드를 만나면 `자신이 수행해야 할 약속된 동작`을 수행한다.
      * var 키워드를 만나면 새로운 변수를 선언한다.

* 변수 선언
  ```javascript
  var temp;
  ```
  * 변수 이름을 등록하고 메모리 공간을 확보한다.
  *  `자바스크립트 엔진에 의해 undefined라는 값이 암묵적으로 할당되어 초기화된다.`
       1. 선언 : 변수 이름을 등록해 자바스크립트 엔진에 존재를 알린다.
       2. 초기화 : 메모리 공간을 확보하고 `암묵적으로 undefined`를 할당해 초기화
  * 암묵적으로 초기화하기 때문에 `쓰레기 값으로부터 안전`하다.
  * 변수 선언은 필수며, 선언하지 않은 식별자에 접근하면 `ReferenceError(참조 에러)`가 발생한다.
    * 참조하려 했으나 식별자를 찾을 수 없을 때 발생

### 변수 선언의 실행 시점

* 코드 에러가 안 나는 이유
  ```javascript
  console.log(temp);
  var temp;
  ```
  * 자바스크립트는 인터프리터에 의해 순차적 실행된다.
  * 하지만, `변수 선언은 런타임이 아니라 이전 단계에 먼저 실행`된다.
    * 순차적 실행에 앞서 자바스크립트는 소스코드의 평가 과정을 거친다.
    * 이때 자바스크립트 엔진은 `모든 선언문을 소스코드에서 찾아 먼저 실행`한다.
    * 평가 과정이 끝나면 `모든 선언문을 제외`하고 소스코드를 순차 실행한다.
  * 변수 선언이 어디에 있든 `다른 코드보다 먼저 실행`한다.
  * 따라서 어디에 있어도 변수를 참조할 수 있다.
* 변수 호이스팅(variable hoisting)
  * `변수 선언이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트의 특징을 변수 호이스팅이라 한다.`
  * 변수 뿐 아니라 모든 식별자는 호이스팅된다. 

### 값의 할당

* 값의 할당
  ```javascript
  var temp = 40;
  ```
  * 하나의 문장으로 표현해도 2개의 문장으로 나누어 실행한다.
    * 이 역시 undefined가 할당되어 초기화되는 것에는 변함이 없다.
    * 동일하게 `변수 선언과 값의 할당` 실행 시점은 다르다.
  * `기존의 메모리를 지우는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 값을 할당한다.`
    * undefined가 저장된 메모리 공간을 지우는 것이 아니다.
* 값의 재할당
  * 변수에 새로운 값을 재할당
  ```javascript
  var temp = 40;
  temp = 50;
  ```
  * 사실 선언과 동시에 undefined 초기화하기 때문에 `처음으로 값을 할당하는 것도 재할당`이다.
    * 값을 재할당하면 temp는 이전 값 40에서 50으로 변경된다.
    * `마찬가지로 새로운 메모리 공간을 확보하고 그 메모리 공간에 50을 저장한다.`
  * 이 경우 40은 어떤 식별자와도 연결되어 있지 않은 `가비지 값`이 된다.
    * 이러한 불필요한 것들은 `가비지 콜렉터에 의해 자동 해제`된다.

* 가비지 콜렉터
  * 애플리케이션이 할당한 메모리 공간을 주기적으로 검사해 사용되지 않는 메모리를 해제한다.
    * 사용되지 않는 메모리란?
    * 어떤 식별자도 참조하지 않는 메모리 공간이다.
  * 메모리 누수를 방지해준다.